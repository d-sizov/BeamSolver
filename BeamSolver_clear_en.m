(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["BeamSolver`"];


(* ::Input::Initialization:: *)
Unprotect@@Names["BeamSolver`*"];
ClearAll@@Names["BeamSolver`*"];


(* ::Input::Initialization:: *)
beamQ;
beamSolve;
beamPutValues;
beamReactions;
beamPlots;
beamMaxValue;
beamInitialParameters;
removePrivateContext;


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
Needs["StaticEquilibrium`"]


(* ::Input::Initialization:: *)
Needs["MyPlots`"]


(* ::Input::Initialization:: *)
noNullInsideQ[arg_]:=Not@MemberQ[arg,Null]


(* ::Input::Initialization:: *)
loadingQ[arg_Association]:=MatchQ[arg["Type"],"Force"|"Moment"|"Distributed"]&&noNullInsideQ[arg]
loadingQ[___]:=False


(* ::Input::Initialization:: *)
forceQ[arg_?loadingQ]:=MatchQ[arg["Type"],"Force"]&&ContainsAll[Keys@arg,{"Type","x","Value"}]
forceQ[___]:=False


(* ::Input::Initialization:: *)
distributedQ[arg_?loadingQ]:=ContainsAll[Keys@arg,{"Type","x begin","x end","Value"}]
distributedQ[___]:=False


(* ::Input::Initialization:: *)
momentQ[arg_?loadingQ]:=MatchQ[arg["Type"],"Moment"]&&ContainsAll[Keys@arg,{"Type","x","Value"}]
momentQ[___]:=False


(* ::Input::Initialization:: *)
supportQ[arg_Association]:=ContainsAll[Keys@arg,{"Type","x"}]
supportQ[___]:=False


(* ::Input::Initialization:: *)
beamQ[arg_Association]:=SubsetQ[Keys@arg,{"Supports","Loadings","Length","E","J"}]&&MatchQ[arg["Loadings"],{__?loadingQ}]&&MatchQ[arg["Supports"],{__?supportQ}]
beamQ[___]:=False


(* ::Input::Initialization:: *)
beamPutValues[beam_?beamQ]:=With[{h\[Theta]s={HeavisideTheta[0]->1,HeavisideTheta[0.]->1}},Map[Evaluate,With[{values=beam["Numbers"]},Map[#/.values/.h\[Theta]s&,Most@beam]],Infinity]/.h\[Theta]s]


(* ::Input::Initialization:: *)
pinQ[beam_?beamQ]:=#["Type"]&/@beam["Supports"]==={"Pin","Pin"}
pinQ[___]:=False


(* ::Input::Initialization:: *)
fixedEndQ[beam_?beamQ]:=#["Type"]&/@beam["Supports"]==={"FixedEnd"}
fixedEndQ[___]:=False


(* ::Input::Initialization:: *)
resultantOfRaspred[arg_?distributedQ]:=<|"Type"->"Force","x"->(#["x end"]+#["x begin"])/2&@arg,"Value"->#["Value"](#["x end"]-#["x begin"])&@arg|>
resultantOfRaspred[arg___]:=arg


(* ::Input::Initialization:: *)
convertForcesForStaticEqulibrium[nagrList:{__?loadingQ}]:=Function[arg,{{0,arg[[2]],0},{arg[[1]],0,0}}]/@(Rest/@Values@Map[resultantOfRaspred,Cases[nagrList,_?(forceQ[#]||distributedQ[#]&)]])


(* ::Input::Initialization:: *)
convertMomentsForStaticEqulibrium[nagrList:{__?loadingQ}]:=#[[2]]&/@(Rest/@Values@Cases[nagrList,_?(momentQ[#]&)])


(* ::Input::Initialization:: *)
momentPoints[beam_?beamQ]:={{0,0,0},{beam["Length"],0,0}}


(* ::Input::Initialization:: *)
reactionsEquations[beam_?pinQ]:=StaticEquilibrium`zmomentEquation[
momentPoints[beam],
(convertForcesForStaticEqulibrium@beam["Loadings"])~Join~{{{0,reac`yA,0},{beam["Supports"][[1]]["x"],0,0}},{{0,reac`yB,0},{beam["Supports"][[2]]["x"],0,0}}},convertMomentsForStaticEqulibrium@beam["Loadings"]]

reactionsEquations[beam_?fixedEndQ]:=With[{forces=(convertForcesForStaticEqulibrium@beam["Loadings"])~Join~{{{0,reac`Y,0},{beam["Supports"][[1]]["x"],0,0}}}},
StaticEquilibrium`zmomentEquation[
{{beam["Supports"][[1]]["x"],0,0}},
forces,(convertMomentsForStaticEqulibrium@beam["Loadings"])~Join~{reac`M}]~Join~StaticEquilibrium`projectionEquation[{"y"},forces[[All,1]]]
]


(* ::Input::Initialization:: *)
reactionsSolver[reactions:{_Symbol,_Symbol}]:=Function[eqs,Solve[eqs,reactions][[1]]]


(* ::Input::Initialization:: *)
findReactions[beam_?pinQ]:=reactionsSolver[{reac`yA,reac`yB}]@reactionsEquations[beam]
findReactions[beam_?fixedEndQ]:=reactionsSolver[{reac`Y,reac`M}]@reactionsEquations[beam]


(* ::Input::Initialization:: *)
convertReactionsForBeam[beam_?pinQ]:=(Thread[f@@{#["x"]&/@beam["Supports"],Values@findReactions[beam]}])/.f->(<|"Type"->"Force","x"->#1,"Value"->#2,"Kind"->"Reaction"|>&)

convertReactionsForBeam[beam_?fixedEndQ]:=Module[{Y,M},
{{Y,M}=Values@findReactions[beam]};
{
<|"Type"->"Force","x"->beam["Supports"][[1]]["x"],"Value"->Y,"Kind"->"Reaction"|>,
<|"Type"->"Moment","x"->beam["Supports"][[1]]["x"],"Value"->M,"Kind"->"Reaction"|>
}
]


(* ::Input::Initialization:: *)
findAndInsertReactions[beam_?beamQ]:=Insert[beam,"Loadings"->Join[beam["Loadings"],convertReactionsForBeam[beam]],"Loadings"]


(* ::Input::Initialization:: *)
beamWithReactionsQ[beam_?beamQ]:=MemberQ[Flatten[Keys@beam["Loadings"]],"Kind"]
beamWithReactionsQ[___]:=False


(* ::Input::Initialization:: *)
beamReactions[beam_?beamWithReactionsQ]:=Select[beam["Loadings"],MemberQ[Keys@#,"Kind"]&]


(* ::Input::Initialization:: *)
supportBCs[beam_?pinQ]:=y[#]==0&/@(#["x"]&/@beam["Supports"])
supportBCs[beam_?fixedEndQ]:={y[#]==0,y'[#]==0}&@(beam["Supports"][[1]]["x"])


(* ::Input::Initialization:: *)
endMoment[beamWithReactions_?beamWithReactionsQ,"Left"]:=With[{selected=Select[beamWithReactions["Loadings"],(#["Type"]==="Moment"&&(#["x"]===0||#["x"]===0.))&]},If[Length@selected>0,-selected[[1]]["Value"],0]]

endMoment[beamWithReactions_?beamWithReactionsQ,"Right"]:=(*0*)With[{selected=Select[beamWithReactions["Loadings"],(#["Type"]==="Moment"&&(#["x"]===beamWithReactions["Length"]))&]},If[Length@selected>0,selected[[1]]["Value"],0]]


(* ::Input::Initialization:: *)
endBCs[beamWithReactions_?beamWithReactionsQ]:={y''[0]==endMoment[beamWithReactions,"Left"],y''[beamWithReactions["Length"]]==endMoment[beamWithReactions,"Right"]}


(* ::Input::Initialization:: *)
fullBoundaryConditions[beamWithReactions_?beamWithReactionsQ]:=Join[endBCs[beamWithReactions],supportBCs[beamWithReactions]]


(* ::Input::Initialization:: *)
insertBeforeNumbers[target_?beamQ,key_String,obj_]:=Insert[target,key->obj,-2]


(* ::Input::Initialization:: *)
findAndInsertBoundaryConditions[beamWithReactions_?beamWithReactionsQ]:=insertBeforeNumbers[beamWithReactions,"Boundary conditions",fullBoundaryConditions@beamWithReactions]


(* ::Input::Initialization:: *)
beamWithBoundaryConditionsQ[beam_?beamQ]:=MemberQ[Keys@beam,"Boundary conditions"]
beamWithBoundaryConditionsQ[___]:=False


(* ::Input::Initialization:: *)
compensDistributed[arg_?distributedQ]:=-arg["Value"]HeavisideTheta[x-arg["x end"]]


(* ::Input::Initialization:: *)
equationTerm[beamWithReactions_?beamWithReactionsQ,arg_?forceQ]:=arg["Value"]DiracDelta[x-arg["x"]]
equationTerm[beamWithReactions_?beamWithReactionsQ,arg_?momentQ]:=-arg["Value"]DiracDelta'[x-arg["x"]]If[arg["x"]===beamWithReactions["Length"],0,1]
equationTerm[beamWithReactions_?beamWithReactionsQ,arg_?distributedQ]:=arg["Value"]HeavisideTheta[x-arg["x begin"]]+compensDistributed[arg]


(* ::Input::Initialization:: *)
createEquation[beamWithReactions_?beamWithReactionsQ]:=y''''[x]==Total[equationTerm[beamWithReactions,#]&/@beamWithReactions["Loadings"]]


(* ::Input::Initialization:: *)
createAndInsertEquation[beamWithReactions_?beamWithReactionsQ]:=insertBeforeNumbers[beamWithReactions,"Equation",createEquation@beamWithReactions]


(* ::Input::Initialization:: *)
desiredFunctions={y'''[x],y''[x],y'[x],y[x]};


(* ::Input::Initialization:: *)
beamSolveDE[eq_,boundaryConditions_]:=Quiet[DSolveValue[Join[{eq},boundaryConditions],desiredFunctions,x]/.{HeavisideTheta[0]->1,HeavisideTheta[0.]->1,DiracDelta[0.]->0},{Reduce::ratnz}]
beamSolveDE[beamWithReactionsEquationsAndBCs_?(beamWithBoundaryConditionsQ[#]&&beamWithReactionsQ[#]&)]:=beamSolveDE[beamWithReactionsEquationsAndBCs["Equation"],beamWithReactionsEquationsAndBCs["Boundary conditions"]]


(* ::Input::Initialization:: *)
createBeamFunction[expression_]:=Function[{x1},Evaluate[(expression/.x->x1)]]


(* ::Input::Initialization:: *)
solveDEAndInsertSolution[beamWithReactionsEquationsAndBCs_?(beamWithBoundaryConditionsQ[#]&&beamWithReactionsQ[#]&)]:=insertBeforeNumbers[beamWithReactionsEquationsAndBCs,"Solutions",Map[createBeamFunction,Association@@Thread[Head/@desiredFunctions->(beamSolveDE@beamWithReactionsEquationsAndBCs/.{Q_,M_,\[Theta]_,y_}:>({Q,M,\[Theta]/(#["E"]#["J"]),y/(#["E"]#["J"])}&@beamWithReactionsEquationsAndBCs))]]]


(* ::Input::Initialization:: *)
symbolsInExpr[arg_]:=Cases[Variables@Level[arg,{-1}],_Symbol]


(* ::Input::Initialization:: *)
valuesQ[arg_List]:=MatchQ[arg,{Rule[_Symbol,_?NumberQ]..}]&&noNullInsideQ[arg]
valuesQ[___]:=False


(* ::Input::Initialization:: *)
beamSolve[beam_?beamQ]/;(ContainsAll[beam["Numbers"][[All,1]],symbolsInExpr[beam]]&&valuesQ[beam["Numbers"]]):=(solveDEAndInsertSolution@createAndInsertEquation@findAndInsertBoundaryConditions@findAndInsertReactions@beam)/.DiracDelta[0]->0.(*fixes DiracDelta[0] bug when a force is applied in a support*)


(* ::Input::Initialization:: *)
solvedBeamQ[arg_?beamQ]:=MemberQ[Keys@arg,"Solutions"]
solvedBeamQ[___]:=False


(* ::Input::Initialization:: *)
solvedBeamWithValuesQ[arg_?solvedBeamQ]:=Not@MemberQ[Keys@arg,"Numbers"]
solvedBeamWithValuesQ[___]:=False


(* ::Input::Initialization:: *)
beamPlots[solvedBeam_?solvedBeamWithValuesQ,opts:OptionsPattern[]]:=myPlot[solvedBeam["Solutions"][#][x],{x,-0.001,1.001solvedBeam["Length"]},Exclusions->None,FrameLabel->{"x",#/.{y'''->"y'''",y''->"y''",y'->"y'",y->"y"}},AxesOrigin->{0,0},Filling->Axis,opts]&/@(Head/@desiredFunctions)


(* ::Input::Initialization:: *)
removePrivateContext[expression_]:=ToExpression@StringReplace[ToString[expression],"BeamSolver`Private`"->""]


(* ::Input::Initialization:: *)
beamMaxValue[solvedBeamWithValues_?solvedBeamWithValuesQ,parameter:"y'''"|"y''"|"y'"|"y",interval:{xmin_,xmax_}]/;xmin>=0&&xmax<=solvedBeamWithValues["Length"]:=removePrivateContext@MaximalBy[Quiet@Through[{NMinimize,NMaximize}[##]]&[{solvedBeamWithValues["Solutions"][ToExpression["BeamSolver`Private`"<>parameter]][x],xmin<=x<=xmax},x],Abs[#[[1]]]&]

beamMaxValue[solvedBeamWithValues_?solvedBeamWithValuesQ,parameter:"y'''"|"y''"|"y'"|"y"]:=beamMaxValue[solvedBeamWithValues,parameter,{0,solvedBeamWithValues["Length"]}]


(* ::Input::Initialization:: *)
beamInitialParameters[solvedBeamWithValues_?solvedBeamWithValuesQ]:=Thread[{"\!\(\*SubscriptBox[\(\[Theta]\), \(0\)]\)","\!\(\*SubscriptBox[\(y\), \(0\)]\)"}->Through[{solvedBeamWithValues["Solutions"][y'],solvedBeamWithValues["Solutions"][y]}[0.]]]/.DiracDelta[0.]->0.


(* ::Input::Initialization:: *)
End[];
Protect@@Names["BeamSolver`*"];
EndPackage[]
